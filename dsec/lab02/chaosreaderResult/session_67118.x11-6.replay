#!/usr/bin/perl
#
# This is a X11 replay program. It will replay a session using
# the timestamps from the packet log, and transpose the X11 protocol so
# that it can be redisplayed. You must have captured from the start
# of the connection for this to work.
#
# USAGE: ./session_0001.X11.replay [-d destination host] [-p port] factor
#
#	just run the script as normal. You can provide a factor as an
#	argument, eg "2" to run twice as fast, or "0.5" to run
#	at half time. eg,
# 		./session_0002.X11.replay 2
#	a different host and port can be specified if needed. eg,
#		./session_0002.X11.replay -d 192.168.1.5 -p 6001
#
# PROBLEMS: you may need to authorise this connection to the X11 server
#	before it works. You could run "xhost +hostname" beforehand.
# 	The playback needs to have captured the start of the connection.
#	Check you support the same colour depth as the playback. And check
#	the playback file simply isn't too big! (more than 500 Kb is
#	currently problematic).
#
#
# Auto generated by Chaosreader.
#

use IO::Socket;
use Getopt::Std;

if ($ARGV[0] =~ /^-h$|^--help$/) { &help(); }

# Try fetching values from $DISPLAY
($hostdef,$portdef) = $ENV{DISPLAY} =~ /([^:]*):(\d*)/;
$hostdef = "127.0.0.1" if $hostdef eq "";
$portdef += 6000;

# Command line options take preference
&getopts('d:p:');
if (defined $opt_d) { $host = $opt_d; } else { $host = $hostdef; }
if (defined $opt_p) { $port = $opt_p; } else { $port = $portdef; }
$factor = $ARGV[0] || 1;
$DEBUG = 0;
$| = 1;

print "Chaosreader X11 Replay (experimental)\n\n";
print "Connecting to $host:$port\n";
print "(problems? try running \"xhost +hostname\" first).\n\n";


# --- Open Socket ---
#
$remote = IO::Socket::INET->new( Proto => "tcp",
				PeerAddr  => $host,
				PeerPort  => $port,
				);
unless ($remote) { die "ERROR42: Can't connect to X11 daemon on $host:$port"; }
$remote->autoflush(1);


# --- Subroutines ---
#

# ms - sleeps for specified milliseconds
#
sub ms {
	$ms = shift;
	$ms = $ms / $factor;
	select(undef, undef, undef, $ms);
}
# help - print help
#
sub help {
        open (MYSELF,"$0") || die "ERROR43: I can't see myself: $!\n";
        @Myself = <MYSELF>;
        close MYSELF;
        ### Print comment from top of code
        foreach $line (@Myself) {
                last if $line !~ /^#/;
                next if $line =~ m:^#!/usr/bin/perl:;
                $line =~ s/^#/ /;
                print $line;
        }
        print "\n";
        exit(0);
}
# R - recalculates and prints a resourse setting
#     The single character subroutine name saves on file space below.
#
sub R {
	#$offset = shift;
	#$new = $res + $offset;
	my $rid = shift;
	my $new;

	# final checks
	$diff = $rid - $ridbaseold;
	$diff = -$diff if $diff < 0;
	if ((($rid < $ridbaseold) && ($rid < 8196)) || ($diff > 8196)) {
	   if ($msb) { return pack('N',$rid); }
		else { return pack('V',$rid); }
	}

	$new = $rid & $ridmaskold;
	$new = $new | $ridbase;
	if ($msb) { return pack('N',$new); }
	     else { return pack('V',$new); }
}
# D - prints the new Drawable, usually the rootid.
#
sub D {
	my $rid = shift;

	# final checks
	if ($rid >= $ridbaseold) {
		# return mapped resource id
		return R($rid);
	}
	# return rootid
	if ($msb) { return pack('N',$rootid); }
	     else { return pack('V',$rootid); }
}
# C - prints the new Colour map.
#
sub C {
	my $rid = shift;

	# final checks
	if ($rid >= $ridbaseold) {
		# return mapped resource id
		return R($rid);
	}
	# return colour map
	if ($msb) { return pack('N',$colour); }
	     else { return pack('V',$colour); }
}
# M - Returns a generic mapped id. Can be rootid, colour, or resource.
#     These are used in Xcodes involving a mask.
#
sub M {
	my $rid = shift;

	# final checks
	if ($rid >= $ridbaseold) {
		# return mapped resource id
		return R($rid);
	}
	# return rootid map
	if ($rid == $rootidold) {
	   if ($msb) { return pack('N',$rootid); }
		else { return pack('V',$rootid); }
	}
	# return colour map
	if ($rid == $colourold) {
	   if ($msb) { return pack('N',$colour); }
		else { return pack('V',$colour); }
	}
	# return other
	if ($msb) { return pack('N',$rid); }
		else { return pack('V',$rid); }
}
# P - Check depth pixels, print warning if there is a mismatch.
#
sub P {
	my $depth = shift;
	if (! defined $Depth{$depth}) {
		print "\nWARNING: requested depth $depth may not be ".
		 "supported by the server?\n";
	}
}
# debug - print out a value
#
sub debug {
	my $word = shift;
	my $num = shift;
	my $pack = pack("N",$num);
	print "$word: $num ",
	 sprintf("%2.2x%2.2x%2.2x%2.2x\n",unpack("C*",$pack));
}


# --- MAIN ---
#
print "Sending X11 traffic:";
print '.';
print $remote '';
print "
";
close $remote;
